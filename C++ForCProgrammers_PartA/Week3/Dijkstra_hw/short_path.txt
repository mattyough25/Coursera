// Shortest Path Algorithm
// 06 January 2022

#include <bits/stdc++.h>
using namespace std;

typedef pair<int, double> E; // Edge is a pair of end vertex and cost

class Graph {
  private:
    int numV; // The number of vertices in the graph
    int numE; // The number of edges in the graph
    vector<E> * G; // The adjacent matrix of graph
  public:
    Graph(int size, double density, double dist_min, double dist_max); // ctor for Graph
    ~Graph(void); // dtor for Graph
    int size(void); // Getter for number of vertices in graph
    int numEdges(void); // Getter for number of edges in graph
    void averageShortestPath(int source); // get the average shortest path from source
    void addEdge(int source, int target, double cost); // adds an edge to the Graph
};

const double INF = numeric_limits<double>::infinity(); // infinite value

// Returns a random double between 0 and 1 used as a probabilty
inline double prob(void) {
  random_device rd; // used as random seed
  static mt19937 rng; // create random generator
  rng.seed(rd()); // input the seed into the rng
  uniform_real_distribution<double> probability(0, 1); // create distribution
  return probability(rng); // return the random probability
}

// size: the number of vertices in the graph
// density: density of edges in the graph
// dist_min: mininum cost of an edge
// dist_max: maximum cost of an edge
Graph::Graph(int size, double density, double dist_min, double dist_max) : numV(size) {
  random_device rd; // used as a random seed
  mt19937 rng; // create random number generator
  rng.seed(rd()); // feed the seed into the rng
  uniform_real_distribution<double> randDist(dist_min, dist_max);

  G = new vector<E>[size]; // allocate memory for graph

  // populate the graph with edges according to the density
  for(int i = 0; i < size; i++) {
    for(int j = 0; j < size; j++) {
      if(i != j && prob() < density) {
        double tempDist = randDist(rng); // random cost for the edge
        // undirected edge, so make edge both ways
        addEdge(i, j, tempDist);
      }
    }
  }
}

// source: the first vertex of the edge
// target: the second vertex of the edge
// cost: the distance of the edge
void Graph::addEdge(int source, int target, double cost) {
  G[source].push_back(make_pair(target, cost));
  G[target].push_back(make_pair(source, cost));
  numE++;
}

// Deallocate the graph
Graph::~Graph(void) {
  vector<E>().swap(*G); // swap out with an empty vector, deallocating memory
}

// Returns the number of vertices in the graph
int Graph::size(void) {
  return numV;
}

// Returns the number of edges in the graph
int Graph::numEdges(void) {
  return numE;
}

// Returns the average of the shortest path from the source vertex to every
// other vertex of the graph. 
// Ignores vertices that are not connected to the source vertex
void Graph::averageShortestPath(int source) {
  // minHeap priority_queue for storing closed vertices
  priority_queue<E, vector<E>, greater<E>> minHeap;

  // Stores distances of vertices from the source
  vector<double> dist(numV, INF);
  dist[source] = 0; // set source dist as 0 since it is itself
  minHeap.push({0, source}); // start with the source vertex

  while(!minHeap.empty()) {
    int nextV = minHeap.top().second; // get the vertex on top
    minHeap.pop(); // remove the top vertex
    for(auto &next : G[nextV]) { // loop through vertices connect to nextV
      int tempV = next.first; // the vertex connected
      double tempC = next.second; // the edge to the connected vertex

      if(dist[tempV] > dist[nextV] + tempC) {
        // found a shorter path => update the distance
        dist[tempV] = dist[nextV] + tempC;
        minHeap.push({dist[tempV], tempV});
      }
    }
  }

  // Get the average by summing up the distances while excluding those that are not connected
  double avg = 0.0;
  int notConnected = 0;
  for(double d : dist) {
    if(d == INF) {
      notConnected++;
      continue;
    }
    avg += d;
  }
  cout << "Number of vertices not connected to vertex " << source << " is: " << notConnected << endl;
  avg /= (numV - notConnected - 1);

  // report the avg shortest path
  cout << "Average shortest path from vertex " << source <<
    " is: " << avg << endl;
}

// Main function driver
int main(void) {

   int size = 0;
   double density, cost_min, cost_max;

   cout<<"Enter Graph Size"<<endl;
   cin >> size;

   cout<<"Enter Graph Density"<<endl;
   cin >> density;

   cout<<"Enter Minimum Cost from Vertex to Vertex"<<endl;
   cin >> cost_min;

   cout<<"Enter Maximum Cost from Vertex to Vertex"<<endl;
   cin >> cost_max;

  cout << "Output with " << density << " density:" << endl;
  Graph graph = Graph(size, density, cost_min, cost_max);
  cout << "Graph Size: " << graph.size() << "; Edge Number: " << graph.numEdges() << endl;
  graph.averageShortestPath(0);

  system("pause");
}

// Output for 20% weight of Dijkstra
// shortest path algorithm

C:\Users\mgy0003\Documents\GitHub\Coursera\C++ForCProgrammers_PartA\Week3\Dijkstra_hw>a
Enter Graph Size
50
Enter Graph Density
0.2
Enter Minimum Cost from Vertex to Vertex
1
Enter Maximum Cost from Vertex to Vertex
10
Output with 0.2 density:
Graph Size: 50; Edge Number: 452
Number of vertices not connected to vertex 0 is: 0
Average shortest path from vertex 0 is: 4.19127
Press any key to continue . . .

// Output for 40% weight of Dijkstra
// shortest path algorithm

C:\Users\mgy0003\Documents\GitHub\Coursera\C++ForCProgrammers_PartA\Week3\Dijkstra_hw>a
Enter Graph Size
50
Enter Graph Density
0.4
Enter Minimum Cost from Vertex to Vertex
1
Enter Maximum Cost from Vertex to Vertex
10
Output with 0.4 density:
Graph Size: 50; Edge Number: 965
Number of vertices not connected to vertex 0 is: 0
Average shortest path from vertex 0 is: 3.59877
Press any key to continue . . .

// What I've Learned
/*
Through the last two Coursera modules and this homework I have learned a lot about C++ and computer science in general. For starters, I had a minimal background on graph theory, so going through how to generate graphs programmatically using both matrices and lists in C++ helped broaden my programming skills. This section of the class has also taught me how to effectively use classes in similar way that structures were used in C. This opens up my coding library to include all kinds of custom types. I have also learned how useful operator overload can be for writing powerful and efficient C++ code. This homework along with the modules in this section have also taught me how to implement the Dijkstra algorithm. I have learned how to use it to find the shortest path between vertices in a graph. Discovering how the algorithm can be used in real world applications also opened my eyes to how I can tackle applicable problems using my increasing coding skills. 

My program randomly generates a graph from user input that includes: graph size, density, and minimum and maximum cost between vertices. It then uses the Dijkstra algorithm to find the shortest path.
*/